# 备忘学习文档

- [备忘学习文档](#%E5%A4%87%E5%BF%98%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3)
    - [idea](#idea)
    - [tomcat](#tomcat)
    - [chrome浏览器](#chrome%E6%B5%8F%E8%A7%88%E5%99%A8)
        - [常用快捷键](#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE)
        - [查看事件监听](#%E6%9F%A5%E7%9C%8B%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC)
        - [调试模式找不到ajax请求的js](#%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%E6%89%BE%E4%B8%8D%E5%88%B0ajax%E8%AF%B7%E6%B1%82%E7%9A%84js)
        - [模拟网速慢的情况](#%E6%A8%A1%E6%8B%9F%E7%BD%91%E9%80%9F%E6%85%A2%E7%9A%84%E6%83%85%E5%86%B5)
        - [小于12px的字体不渲染的解决方案](#%E5%B0%8F%E4%BA%8E12px%E7%9A%84%E5%AD%97%E4%BD%93%E4%B8%8D%E6%B8%B2%E6%9F%93%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)
    - [http](#http)
        - [跨域 CORS](#%E8%B7%A8%E5%9F%9F-cors)
        - [浏览器缓存机制](#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6)
    - [html](#html)
        - [a标签click不触发转跳](#a%E6%A0%87%E7%AD%BEclick%E4%B8%8D%E8%A7%A6%E5%8F%91%E8%BD%AC%E8%B7%B3)
        - [a标签热键](#a%E6%A0%87%E7%AD%BE%E7%83%AD%E9%94%AE)
        - [事件阶段](#%E4%BA%8B%E4%BB%B6%E9%98%B6%E6%AE%B5)
    - [javascript](#javascript)
        - [三种声明方式的区别](#%E4%B8%89%E7%A7%8D%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB)
        - [jquery动态事件绑定](#jquery%E5%8A%A8%E6%80%81%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A)
        - [JS打开新窗口的2种方式](#js%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3%E7%9A%842%E7%A7%8D%E6%96%B9%E5%BC%8F)
        - [javascript 函数call apply区别](#javascript-%E5%87%BD%E6%95%B0call-apply%E5%8C%BA%E5%88%AB)
        - [javascript 正则表达式可视化](#javascript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%AF%E8%A7%86%E5%8C%96)
        - [字节序-大小端](#%E5%AD%97%E8%8A%82%E5%BA%8F-%E5%A4%A7%E5%B0%8F%E7%AB%AF)
    - [nodejs](#nodejs)
    - [mongo](#mongo)
        - [CAP理论](#cap%E7%90%86%E8%AE%BA)
        - [安装步骤](#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4)
        - [备份与恢复](#%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D)
    - [freemarker 语法](#freemarker-%E8%AF%AD%E6%B3%95)
    - [JAVA](#java)
        - [ocr识别（图片转文字）](#ocr%E8%AF%86%E5%88%AB%EF%BC%88%E5%9B%BE%E7%89%87%E8%BD%AC%E6%96%87%E5%AD%97%EF%BC%89)
        - [线程](#%E7%BA%BF%E7%A8%8B)
        - [引用](#%E5%BC%95%E7%94%A8)
    - [git命令](#git%E5%91%BD%E4%BB%A4)
        - [解决git pull push每次都需要输入密码问题](#%E8%A7%A3%E5%86%B3git-pull-push%E6%AF%8F%E6%AC%A1%E9%83%BD%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E9%97%AE%E9%A2%98)
        - [gitignore文件用法](#gitignore%E6%96%87%E4%BB%B6%E7%94%A8%E6%B3%95)
        - [查看命令语法](#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95)
        - [日志命令](#%E6%97%A5%E5%BF%97%E5%91%BD%E4%BB%A4)
    - [markdown](#markdown)
        - [code 语法](#code-%E8%AF%AD%E6%B3%95)
        - [转ppt方案](#%E8%BD%ACppt%E6%96%B9%E6%A1%88)
        - [在线转表格](#%E5%9C%A8%E7%BA%BF%E8%BD%AC%E8%A1%A8%E6%A0%BC)
        - [vscode markdownlint error settings](#vscode-markdownlint-error-settings)
    - [mysql](#mysql)
    - [lucene](#lucene)
    - [maven](#maven)
    - [SpringMVC](#springmvc)
    - [window](#window)
        - [环境变量命令](#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%91%BD%E4%BB%A4)
        - [cmd中复制粘贴](#cmd%E4%B8%AD%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4)
        - [Win7不按Shift，直接右键显示“在此处打开命令窗口(W)”](#win7%E4%B8%8D%E6%8C%89shift%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%8F%B3%E9%94%AE%E6%98%BE%E7%A4%BA%E2%80%9C%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E7%AA%97%E5%8F%A3w%E2%80%9D)
        - [win10多桌面快捷键](#win10%E5%A4%9A%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E9%94%AE)
        - [windows 查找服务名](#windows-%E6%9F%A5%E6%89%BE%E6%9C%8D%E5%8A%A1%E5%90%8D)
        - [windows win+r常用命令](#windows-winr%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4)
        - [windows清除网上邻居帐号](#windows%E6%B8%85%E9%99%A4%E7%BD%91%E4%B8%8A%E9%82%BB%E5%B1%85%E5%B8%90%E5%8F%B7)
        - [windows kill 进程命令](#windows-kill-%E8%BF%9B%E7%A8%8B%E5%91%BD%E4%BB%A4)

## idea

maven控制台中文乱码
> Setting->maven->runner   设置VMoptions: -Dfile.encoding=GB2312

快捷键

- outline 视图 `ctrl+F12`
- 导入包,自动修正 `Alt+回车`
- 查找类 `Ctrl+N`
- 查找文件 `Ctrl+Shift+N`
- 格式化代码 `Ctrl+Alt+L`
- 优化导入的类和包 `Ctrl+Alt+O`
- 生成代码(如get,set方法,构造函数等) `Alt+Insert`
- 最近更改的代码 `Ctrl+E或者Alt+Shift+C`
- 替换文本 `Ctrl+R`
- 查找文本 `Ctrl+F`
- 自动补全代码 `Ctrl+Shift+Space`
- 代码提示 `Ctrl+空格`
- 类名或接口名提示 `Ctrl+Alt+Space`
- 方法参数提示 `Ctrl+P`
- 查找类中的方法或变量 `Ctrl+Shift+Alt+N`
- 对比最近修改的代码 `Alt+Shift+C`
- 重构-重命名 `Shift+F6`
- 移动行 `Ctrl+Shift+先上键`
- 删除行 `Ctrl+X``Ctrl+Y`
- 复制行 `Ctrl+D`
- 注释（//或者/*...*/） `Ctrl+/` `Ctrl+Shift+/`
- 自动代码 `Ctrl+J`
- 最近打开的文件 `Ctrl+E`
- 显示类结构图 `Ctrl+H`
- 显示注释文档 `Ctrl+Q`
- 查找代码所在位置 `Alt+F1`
- 快速打开或隐藏工程面板 `Alt+1`
- 返回至上次浏览的位置 `Ctrl+Alt+left/right`
- 切换代码视图 `Alt+left/right`
- 在方法间快速移动定位 `Alt+Up/Down`
- 代码向上/下移动。 `Ctrl+Shift+Up/Down`
- 高亮错误或警告快速定位 `F2或Shift+F2`
- 代码标签输入完成后，按Tab，生成代码。 `tab`
- 选中文本，高亮显示所有该文本，按Esc高亮消失。 `Ctrl+Shift+F7`
- 选中代码，连续按会有其他效果 `Ctrl+W`
- 选中文本，逐个往下查找相同文本，并高亮显示。 `按Alt+F3`
- 光标跳转到第一行或最后一行下 `Ctrl+Up/Down`
- 快速打开光标处的类或方法 `Ctrl+B`
- 大小写 `ctrl+shift+U`
- 选定代码块(trycatch if for) `Ctrl+Shift+T`

自定义快捷键

- 左右分屏 `alt+]`
- 上下分屏 `alt+[`
- 复制整行 `ctrl+win`

文件颜色

> 绿色：已经加入版本控制暂未提交；
> 红色：未加入版本控制；  
> 蓝色：加入版本控制，已提交，有改动；  
> 白色：加入版本控制，已提交，无改动；  
> 灰色：版本控制已忽略文件。

编码快捷

- 100.fori list.for 快速for循环

在intellij idea中打jar包，运行提示没有主清单属性
> 可能是 IntelliJ 的问题。
> 在 Project Structure - Artifacts 里面选好 Main Class 之后，IntelliJ 会自动在下边的 Directory for META-INF/MANIFEST.MF 里填上 `/$PROJECT_DIR/src/main/java`
把这行里边的 `main/java` 删掉，变成 `/$PROJECT_DIR/src/` 试试

maven乱码
> windows环境下，Intellij idea12中maven操作时，控制台中文乱码问题（编译报错或者clean install时出现的其他错误描述乱码）
> 在cmd中mvn中文正常显示,log4j打印日志也是ok的。
> 解决方法：
> Setting->maven->runner  VMoptions: -Dfile.encoding=GB2312

intellij 出现“Usage of API documented as @since 1.6+”的解决办法
> File ->Project Structure->Project Settings -> Modules -> 你的Module名字 -> Sources -> Language Level->选个默认的就行。

ctrl+space冲突问题
> 修改注册表 HKEY_CURRENT_USER/Control Panel/Input Method/Hot Keys
00000070 for the Chinese (Traditional) IME - Ime/NonIme Toggle hotkey
00000010 for the Chinese (Simplified) IME - Ime/NonIme Toggle hotkey
把Key Modifiers开头的02改成00
把Virtual Key开头的20改成FF

修改提示首字母区分大小写的问题
> 在IDEA中进行代码提示时，原来在ECLIPSE中输入syso,然后"Alt+/"就可以完成System.out.println("")的输入，但是在IDEA中默认的配置首字母必须输入“S”大小写一致才能匹配到System，如果要输入小写“s”都可以匹配，需要在
> Editor=>Code Completion里把Case sensitive completion设置为None就可以了

日志
> edit configurations > "your server" > logs > add > alias and log file location  
> 5:debug > log > all

## tomcat

> tomcat7默认编码iso8859-1，tomcat8默认编码utf8

## chrome浏览器

### 常用快捷键

| 按键              | 功能               |
|-------------------|--------------------|
| `Ctrl+Shift+C`    | 定位元素(+)        |
| `Ctrl+Shift+D`    | 切换开发工具位置   |
| `Ctrl+Shift+F`    | 全局搜索           |
| `F1`              | 打开设置           |
| `Esc`             | 打开/隐藏底部      |
| `Ctrl+Shift+J`    | 打开/关闭控制台(+) |
| `Ctrl+L`          | 控制台清空         |
|                   |                    |

备注：(+)不用打开控制台

### 查看事件监听

在Elements标签下，找到dom元素，打开EventListeners,取消Ancestors['ænsɛstɚ]的勾选(祖先)

### 调试模式找不到ajax请求的js

> 搜不到ajax请求的js文件，可以设置settings--preferences--sources--search in anonymous and conten script 勾选,用ctrl+shift+f进行搜索

### 模拟网速慢的情况

> 按F12，打开Chrome调试工具 setting>Throttlting>add customer profile  
> 在network标签下选择 no throttling-->add ，再输入相应的限速即可

### 小于12px的字体不渲染的解决方案

> 不要设置小于12px的，因为小于12px中文的渲染效果不好  
> 设置chrome的外观最小字体  
> 通过设置css属性

```css
    .chrome_adjust {
        font-size: 12px;
        /* -webkit-text-size-adjust:none; 已失效*/
        display: inline-block;
        -webkit-transform-origin-x:left; /*左侧*/
        -webkit-transform-origin-y:top; /*上侧*/
        width:60px;height:20px;
        -webkit-transform: scale(0.5);
        transform: scale(0.5);
    }
    /*缩放的元素会占用原始的大小，通过定位的方式解决*/
    /*css暂时没有父元素选择器*/
    .chrome_adjust_parent {
        position: relative;
    }
    .chrome_adjust {
        position: absolute;"
    }
```

## http

### 跨域 CORS

"跨域资源共享"（Cross-origin resource sharing）
参考[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

图片跨域
> 错误 Uncaught DOMException: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported.
> 由于canvas受限于 CORS 策略
> 解决方法：img.setAttribute("crossOrigin",'Anonymous')，同时服务器端设置Access-Control-Allow-Origin: * 和 Access-Control-Allow-Methods: GET, POST, PUT就可以了

jsonp跨域 参考 [浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)
> JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。  
> 它的基本思想是，网页通过添加一个`<script>`元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。  
> 首先，网页动态插入`<script>`元素，由它向跨源网址发出请求。  

```javascript
    function addScriptTag(src) {
        var script = document.createElement('script');
        script.setAttribute("type","text/javascript");
        script.src = src;
        document.body.appendChild(script);
    }

    window.onload = function () {
        addScriptTag('http://example.com/ip?callback=foo');
    }

    function foo(data) {
        console.log('Your public IP address is: ' + data.ip);
    };
```

> 上面代码通过动态添加`<script>`元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。  
> 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。

```javascript
foo({
  "ip": "8.8.8.8"
});
```

> 由于`<script>`元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。

### 浏览器缓存机制

协商缓存

- `If-Modified-Since/Last-modified`: 服务器程序检查请求头(`request header`)里面的(`If-modified-Since`)，如果最后修改时间相同(例如静态文件的Modified time 通过shell `ls -l`可以查看)则返回304，否则给返回头(`response header`)添加`last-Modified`并且返回数据(response body)。
- `If-None-Match/Etag`：服务器程序检查检查请求头(`request header`)里面的`if-none-match`的值与当前文件的内容通过hash算法（`例如 nodejs: cryto.createHash('sha1')`）生成的内容摘要字符对比，相同则直接返回`304`，否则给返回头(`response header`)添加`etag`属性为当前的内容摘要字符，并且返回内容。

强缓存（from cache）

- 如果设置了`Expires`(XX时间过期)或者`Cache-Control（http1.0不支持）`(经历XX时间后过期)且没有过期，命中`cache`的情况下，`from cache`不去发出请求。如果强刷（如ctrl+r）会发起请求，但是如果没有修改会返回`304`内容未修改，如果已经改变则返回新内容。
- expires/cache-control 虽然是强缓存，但用户主动触发的刷新行为，还是会采用缓存协商的策略，主动触发的刷新行为包括点击刷新按钮、右键刷新、f5刷新、ctrl+f5刷新等。
- 当然如果在控制台里面选中了`disable cahce`则无论如何都会请求最新内容(304协商缓存、强缓存都无效)，因为

1. 不会检查本地是否有缓存。
1. 请求头信息(request header)既没有If-Modified-Since也没有If-None-Match来让服务端判断。

地址栏输入的地址按下回车键，该地址页面请求（仅仅是该url）的`request header`都会带上`cache-contro:max-age=0`，所以不会命中强缓存（参考：How do I stop Chrome sending Cache-control: max-age=0 when I hit enter?），但是通过链接点击的地址会命中缓存。
chrome下查看所有的from cache文件：[chrome://view-http-cache/](chrome://view-http-cache/)

## html

### a标签click不触发转跳

```html
<a id="alink" href="abc.aspx" style="visibility: hidden;">下一步</a>
<script>
    $("#alink").click(); // 触发了a标签的点击事件，但是没有触发页面跳转
    document.getElementById("alink").click(); //既触发了a标签的点击事件，又触发了页面跳转
    $("#alink")[0].click(); // 可将jquery对象转为dom对象从而触发页面转跳
</script>
```

### a标签热键

```html
<a accesskey="n" href="ch06s05.html">下一页</a>
<!-- 表示n是快捷键 其中在chrome/ie下是alt+n,firefox是alt+shift+n  -->
```

### 事件阶段

DOM2级事件规定的时间流包括 三个阶段：

1. 事件捕获阶段
1. 处于目标阶段
1. 事件冒泡阶段

注意：在DOM事件流中，实际的目标在捕获阶段不会接收到事件，下一个阶段是处于目标阶段，这时事件被触发，最后进入事件冒泡阶段。我们认为处于目标阶段是事件冒泡阶段的一部分。

button <- div <- body <- html <- window ----事件捕获  
　 |  
　 ∨  
button <- div -> body -> html -> window ----事件冒泡  
注：如在div上先绑定冒泡事件A后绑定捕获事件B，则触发button时会先触发B后触发A;如果只通过div触发事件则先A后B

阻止事件

> stopImmediatePropagation() 和 stopPropagation()  
后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生。

```html
<!-- demo -->
<!DOCTYPE html>
<html>
    <head>
        <title>demo</title>
        <style>
            *{
                margin-top:20px;
            }
        </style>
    </head>
    <body>
        <div id="bubble" style='height:100px'>
            <div>bubble-div1</div>
            <div>bubble-div2</div>
        </div>
        <div id="capture">
            <div>capture-div1</div>
            <div>capture-div2</div>
        </div>
        <div>
            <a id="A">元素A</a>
        <div>
        <div id='B'>
            <a>元素b</a>
        </div>
    </body>
    <script type="text/javascript">
        //dom.addEventListener('click',handler,boolean);最后一个参数是false为冒泡阶段，最后一个是true为捕获阶段，默认冒泡
        //冒泡
        document.getElementsByTagName('body')[0].addEventListener('click', function(e) {
            alert('body-bubble');
        }, false);
        document.getElementById('bubble').addEventListener('click', function(e) {
            alert('bubble-bubble');
        }, false);
        document.getElementById('bubble').addEventListener('click', function(e) {
            alert('bubble-capture');
        }, true);
        //捕获
        document.getElementsByTagName('body')[0].addEventListener('click', function(e) {
            alert('body-capture');
        }, true);
        document.getElementById('capture').addEventListener('click', function(e) {
            alert('capture');
            e.stopPropagation();
        }, true);

        //同一元素
        var domA = document.getElementById('A');
        //冒泡
        domA.addEventListener('click',function () {
            alert('A-bubble')
        },false)
        //捕获
        domA.addEventListener('click',function () {
            alert('A-capture')
        },true)

        //同一元素
        var domB = document.getElementById('B');
        domB.addEventListener('click',function(){
            alert('B-bubble');
        },false)
        domB.addEventListener('click',function(){
            alert('B-capture');
        },true)
    </script>
</html>

```

## javascript

### 三种声明方式的区别

> 使用`var`声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；  
使用`let`声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；  
使用`const`声明的是常量，在后面出现的代码中不能再修改该常量的值。

### jquery动态事件绑定

```javascript

// jquery on() bind()绑定的点击事件在js动态新添加的元素生效
// 方法一：
$('.class').on("click",function(){……});  //相当于  $('.class').bind("click",function(){……});
$(document).on("click",'.class',function(){……});  //相当于  $('.class').live("click",function(){……});
// js生成的元素绑定事件必须使用live，但新版的jq，已经淘汰了live，可以用on方法代替，但必须注意写法。



// 方法二：
// js动态生产元素的时候，再进行事件绑定一次

```

### JS打开新窗口的2种方式

```javascript

// 1. 超链接
<a href="http://www.100sucai.com/" title="100素材网">Welcome</a>

// 等效于js代码
window.location.href="http://www.100sucai.com/";     //在同当前窗口中打开窗口

// 2.超链接
<a href="http://www.100sucai.com/" title="100素材网" target="_blank">Welcome</a>

// 等效于js代码
window.open("http://www.100sucai.com/");                 //在另外新建窗口中打开窗口

```

### javascript 函数call apply区别

```javascript

obj.call(thisObj, arg1, arg2, ...);
obj.apply(thisObj, [arg1, arg2, ...]);
//两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。唯一区别是apply接受的是数组参数，call接受的是连续参数。

function add(j, k){
    return j+k;
}

function sub(j, k){
    return j-k;
}

// 我们在控制台运行：
add(5,3); //8
add.call(sub, 5, 3); //8
add.apply(sub, [5, 3]); //8

sub(5, 3); //2
sub.call(add, 5, 3); //2
sub.apply(add, [5, 3]); //2

// 通过call和apply，我们可以实现对象继承。示例：
var Parent = function(){
    this.name = "yjc";
    this.age = 22;
}

var child = {};

console.log(child);//Object {} ,空对象

Parent.call(child);

console.log(child); //Object {name: "yjc", age: 22}
// 以上实现了对象的继承。

```

### javascript 正则表达式可视化

[debuggex](https://www.debuggex.com/)  
[regexper](https://regexper.com)

### 字节序-大小端

大端序 big-endian 高尾序
小端序 little-endian 低尾序

多个字节表示一个字符或整型时有区别
如表示`0x12345678`和`0x11223344`这两个整数  
两者的共识是先存`0x12345678`后存`0x11223344`  

1. 大端序：(--->内存地址增长方向--->)  
    `0x12|0x34|0x56|0x78|  0x11|0x22|0x33|0x44`  
1. 小端序：(--->内存地址增长方向--->)  
    `0x78|0x56|0x34|0x12|  0x44|0x33|0x22|0x11`  

由此也引发了计算机界的大端与小端之争，不同的CPU厂商并没有达成一致：

> x86，MOS Technology 6502，Z80，VAX，PDP-11等处理器为Little endian。  
Motorola 6800，Motorola 68000，PowerPC 970，System/370，SPARC（除V9外）等处理器为Big endian。  
ARM, PowerPC (除PowerPC 970外), DEC Alpha, SPARC V9, MIPS, PA-RISC and IA64的字节序是可配置的。

网络传输中要统一，TCP/IP协议隆重出场，RFC1700规定使用“大端”字节序为网络字节序，其他不使用大端的计算机要注意了，发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。这样就与CPU、操作系统无关了，实现了网络通信的标准化。

BOM 字节顺序标记（英语：byte-order mark，BOM）
utf-8在windows下记事本默认添加bom，可能会导致unix系统下文件不识别

| 编码             | 表示（十六进制） | 表示（十进制） |
|------------------|------------------|----------------|
| UTF-8            | EF BB BF         | 239 187 191    |
| UTF-16（大端序） | FE FF            | 254 255        |
| UTF-16（小端序） | FF FE            | 255 254        |
| UTF-32（大端序） | 00 00 FE FF      | 0 0 254 255    |
| UTF-32（小端序） | FF FE 00 00      | 255 254 0 0    |

js检测字节序

```javascript
    //如果整数0x00000001在内存中表示成：01 00 00 00，
    //则说明当前系统是低位优先系统
    //相反，在高位优先系统中，它会表示成：00 00 00 01
    var little_endian = new Int8Array(new Int32Array([1]).buffer)[0]===1
```

java字节序
Java 中由于 JVM 的存在,因此Java中的字节序是大端(Big-Endian).

```java
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;

public class JVMEndianTest {

    public static void main(String[] args) {

        int x = 0x01020304;

        ByteBuffer bb = ByteBuffer.wrap(new byte[4]);
        bb.asIntBuffer().put(x);
        String ss_before = Arrays.toString(bb.array());

        System.out.println("默认字节序 " +  bb.order().toString() +  ","  +  " 内存数据 " +  ss_before);

        bb.order(ByteOrder.LITTLE_ENDIAN);
        bb.asIntBuffer().put(x);
        String ss_after = Arrays.toString(bb.array());

        System.out.println("修改字节序 " + bb.order().toString() +  ","  +  " 内存数据 " +  ss_after);

        System.out.println("系统字节序 "+ByteOrder.nativeOrder());
    }
}
```

## nodejs

淘宝源

```js
//使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:
npm install -g cnpm --registry=https://registry.npm.taobao.org
//这样就可以使用 cnpm 命令来安装模块了：
$ cnpm install [name]
//更多信息可以查阅：http://npm.taobao.org/。
```

## mongo

### CAP理论

> 一致性(Consistency) (所有节点在同一时间具有相同的数据)  
> 可用性(Availability) (保证每个请求不管成功或者失败都有响应)  
> 分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)  
> 理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。一般来说跨区域的系统，设计师无法舍弃P性质，那么就只能在数据一致性和可用性上做一个艰难选择。不确切地说，NoSQL运动的主题其实是创造各种可用性优先、数据一致性其次的方案；而传统数据库坚守ACID特性（原子性、一致性、隔离性、持久性），做的是相反的事情。

**C和A之间选择不是0和1的选择，而是一种连续式选择**  
好像选择C就必须放弃A，反之亦然。但是其实所有这些都有中间方案。C和A的定义也有各种灰度定义。  
比如C的定义，最严格的定义就是一个分布式事务结束后，所有的副本在任何时刻都是一致的。但是这个定义可以放宽。时间不在是同时，而是一段时间，给一个时间窗口。或者一阶段内可以不一致，但最终变成一致的。比如上面的例子中，在发生分区的时候，可以暂时不一致，等到通信问题解决了，开始恢复一致性。  
而对于A的定义来说，也是有各种层次，在发生分区的时候，可以选择限制部分操作，同时提供一个些事后比较好恢复的操作。

参考[CAP理论十二年回顾："规则"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed/)

### 安装步骤

一、下载mongodb压缩包：mongodb-win32-i386-2.6.9.zip（）  [下载地址](https://www.mongodb.org/dl/win32/x86_64-2008plus-ssl)  
二、在D盘新建文件夹mongodb，将压缩我的解压文件放进去（有一个bin文件夹和另外三个文件）  
三、创建数据库文件存放位置：D：/mongodb/data/db  
四、打开cmd进入bin目录，输入命令 mongod --dbpath D:\mongodb\data\db，启动服务，mongodb默认连接端口为27017，可以使用浏览器打开 `http://localhost:27017`查看，如果看到 it looks like you are .....说明启动成功  
五、可以将mongodb设置成windows服务，这样就不用使用命令启动了，设置方法如下：  
    1、在data文件夹下新建一个log文件夹，用于存放日志文件，在log文件夹下新建文件mongodb.log  
    2、在 D:\mongodb文件夹下新建文件mongo.config，并用记事本打开mongo.config输入以下内容:  
    dbpath=D:\mongodb\data\db  
    logpath=D:\mongodb\data\log\mongodb.log  
    3、以管理员身份打开cmd命令框（开始——输入cmd找到cmd.exe——右键——以管理员身份运行）  
    4、进入bin文件夹输入以下命令mongod --config D:\mongodb\mongo.config --install --serviceName   "MongoDB" --journal  
    5、右键计算机——系统服务，打开win7服务框，本地服务服务列表中会看到MongoDB，表示已经成功将mongodb加入到了系统服务，但是此时服务还没有开启！  
    6、在cmd中输入 net start mongoDB  开启服务，重新查看win7服务显示窗口，发现mongodb的状态栏显示“已启动”，表示启动成功。  
    7、cmd中在bin目录下输入mongo，就连接了mongodb服务了，可以玩mongodb啦！！！  

### 备份与恢复

```javascript
//备份
mongodump -h 'host:port' -d 'database' -u 'user' -p 'password' --authenticationMechanism SCRAM-SHA-1 --authenticationDatabase 'database' --excludeCollectionsWithPrefix=system -o 'outputpath'

//恢复
mongorestore -h 'host:port' 'inputpath'

//帮助
mongodump --help
mongorestore --help

```

查询

```javascript
db.col.find({key1:value1, key2:value2}).pretty()
```

插入

```javascript
document=({
    title: 'MongoDB 教程',
    description: 'MongoDB 是一个 Nosql 数据库'
});
db.COLLECTION_NAME.insert(document)
```

## freemarker 语法

三目运算符

```java
<#if (applyBaseinfoEntity.applyException)??>
      ${(applyBaseinfoEntity.applyException == '0')?string('否','是')?html}
</#if>
```

## JAVA

枚举类通过值获取对象

```java
public static TradeStatus getByValue(int value) {
    for (TradeStatus tradeStatus : values()) {
        if (tradeStatus.getValue() == value) {
            return tradeStatus;
        }
    }
    return null;
}
```

### ocr识别（图片转文字）

[Tesseract-OCR的简单使用与训练](https://www.cnblogs.com/cnlian/p/5765871.html)  
[利用jTessBoxEditor工具进行Tesseract3.02.02样本训练，提高验证码识别率](https://www.cnblogs.com/zhongtang/p/5555950.html)  
[Java OCR tesseract 图像智能字符识别技术 Java代码实现](http://blog.csdn.net/lmj623565791/article/details/23960391)

### 线程

自旋锁: 保护共享资源的一种锁机制, 不引起睡眠, 循环判断是否引起睡眠. 先获取锁, 使用资源, 释放锁. 容易引起死锁  
互斥锁: 引起睡眠等待.  

### 引用

一堆坑, 不推荐使用  
强引用 不会GC 对象的一般状态 JVM停止运行时  
软引用 softReference 内存不足时GC 对象缓存 内存不足时  
弱引用 weakReference 下次GC时 对象缓存 GC后  
虚引用 phantomReference  

## git命令

1、安装原生git、安装一个git客户端（sourceTree/小乌龟git）  
2、新建一个本地仓库：新建文件夹，进入 git bash

```shell
$ mkdir learngit
$ cd learngit
$ pwd
/Users/michael/learngit
# 这就创建了一个仓库
$ git init
Initialized empty Git repository in /Users/michael/learngit/.git/
# 这就初始化了一个仓库
```

3、然后在这个仓库文件夹中新建一个文件，在git bash中就可以add commit了  
4、从远程获取

```shell
git clone http样式的仓库地址，输入用户名密码克隆下来（使用ssh样式需要配置ssh密钥）
```

5、获取分支

```shell
# 进入到克隆下来的文件夹中：
cd 文件夹
git branch
git branch -a
git checkout -b 分支名称 origin/分支名称
# 然后就把分支获取了
```

6、合并分支（记得push到远端）:先在本地合并，然后再push到远端。  
（1）假如说要将dev分支合并到master分支上  
首先，从服务器拉取master代码，并且创建本地分支：`git checkout -b 分支名称 origin/分支名称`  
然后，切换到master分支上：`git checkout master`  
然后，将dev合并到master上： `git merge`  
然后检查代码  
然后将合并好的master分支push到远端：`git push`(就可以使用命令git push origin master推送最新修改；)
（2）给当前分支添加标签tag  
一般都是将分支合并到master之后，在该处的master打一个tag作为标记。  
首先，切换到要打tag的分支，比如master，git checkout master  
然后，git tag 标签的名字，这样就给本地的develop分支打了一个标签；
然后将标签推到远端：git push origin 标签的名字 ，或者使用git push origin --tags 将全部未推送过的本地标签推送到远端。
另外，git tag 查看所以标签；git tag -d 标签名称 删除一个本地标签；git push origin :refs/tags/标签名称  这样删除一个远程标签，注意origin后面的空。
（3）在master上拉取一个新的远端分支，并跟本地分支关联。
因为用命令行是没有办法直接创建新的远端分支的（除非在gitlab上手动创建），做法是先在本地拉取一个新分支，然后推到远端，然后关联
首先，切换到master分支， `git checkout master`
然后，在本地拉取一个新的分支，`git checkout -b b5`(自己取的分支名称，这里就当是b5吧)；
然后，将本地分支推送到远端，`git push origin b5:b5`(第一个b5是本地分支名称，第二个b5是对应远端分支名称)；
然后，将两个分支关联起来，`git checkout b5`切换到b5分支，然后 `git branch -u origin/b5 b5` 这就将两个分支关联起来了。
可以使用命令 `git branch -vv` 查看关联关系

### 解决git pull push每次都需要输入密码问题

如果我们git clone的下载代码的时候是连接的`https://`而不是`git@git` (ssh)的形式，当我们操作git pull/push到远程的时候，总是提示我们输入账号和密码才能操作成功，频繁的输入账号和密码会很麻烦。
解决办法：
git bash进入你的项目目录，输入：
git config --global credential.helper store
然后你会在你本地生成一个文本，上边记录你的账号和密码。当然这些你可以不用关心。
然后你使用上述的命令配置好之后，再操作一次git pull，然后它会提示你输入账号密码，这一次之后就不需要再次输入密码了。

### gitignore文件用法

在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：

```shell
# 此为注释 – 将被 Git 忽略
*.a       # 忽略所有 .a 结尾的文件
!lib.a    # 但 lib.a 除外
/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/    # 忽略 build/ 目录下的所有文件
doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
```

规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：

```shell
git rm -r --cached .
git add .
git commit -m 'update .gitignore'
```

### 查看命令语法

```shell
git help commit # 在浏览器查看commit命令
git commit -help # 在当前窗口查看commit命令
git commit --help # 在浏览器查看commit命令
```

### 日志命令

```shell
git log --stat # 想看到每次提交的简略的统计信息
git log --pretty=oneline # 美化一行
git log --pretty=format:"%h - %an, %ar : %s" # 格式化日志
git log --pretty=format:"%h %s" --graph # ASCII字符 展示你的分支、合并历史
```

## markdown

### code 语法

| 名称             | 关键字                      |
| ---------------- | --------------------------- |
| AppleScript      | applescript                 |
| ActionScript 3.0 | actionscript3   , as3       |
| Shell            | bash   , shell              |
| ColdFusion       | coldfusion   , cf           |
| C                | cpp   , c                   |
| C#               | c#   , c-sharp , csharp     |
| CSS              | css                         |
| Delphi           | delphi   , pascal , pas     |
| diff&patch       | diff   patch                |
| Erlang           | erl   , erlang              |
| Groovy           | groovy                      |
| Java             | java                        |
| JavaFX           | jfx   , javafx              |
| JavaScript       | js   , jscript , javascript |
| Perl             | perl   , pl , Perl          |
| PHP              | php                         |
| text             | text   , plain              |
| Python           | py   , python               |
| Ruby             | ruby   , rails , ror , rb   |
| SASS&SCSS        | sass   , scss               |
| Scala            | scala                       |
| SQL              | sql                         |
| Visual Basic     | vb   , vbnet                |
| XML              | xml   , xhtml , xslt , html |
| Objective C      | objc   , obj-c              |
| F#               | f#   f-sharp , fsharp       |
|                  | xpp   , dynamics-xpp        |
| R                | r   , s , splus             |
| matlab           | matlab                      |
| swift            | swift                       |
| GO               | go   , golang               |

### 转ppt方案

> [nodeppt  nodejs](https://github.com/ksky521/nodePPT)  
> [知乎--使用markdown制作的html幻灯片有哪些？](https://www.zhihu.com/question/35164931)  
> [Markdown转PPT的方法 pandoc reveal.js](http://blog.csdn.net/yyw794/article/details/73697810)  
> [landslide 用Markdown写一个极客范儿的PPT - 简书  python](https://www.jianshu.com/p/e063303317cb)  

### 在线转表格

[Tables Generator](http://www.tablesgenerator.com/markdown_tables)

### vscode markdownlint error settings

修改用户配置,可在[test](https://github.com/DavidAnson/markdownlint/tree/master/test)中查找

## mysql

window开启mysql服务
> net start mysql

## lucene

倒排索引
> 文档是有许多的单词组成的，其中每个单词也可以在同一个文档中重复出现很多次，当然，同一个单词也可以出现在不同的文档中。  
> 正排索引(forward index)：从文档角度看其中的单词，表示每个文档（用文档ID标识）都含有哪些单词，以及每个单词出现了多少次（词频）及其出现位置（相对于文档首部的偏移量）。  
> 倒排索引(inverted index，或inverted files)：从单词角度看文档，标识每个单词分别在那些文档中出现(文档ID)，以及在各自的文档中每个单词分别出现了多少次（词频）及其出现位置（相对于该文档首部的偏移量）。  
> **简单记为：**  
> 正排索引：文档 ---> 单词  
> 倒排索引：单词 ---> 文档  

## maven

本地jar文件安装本地仓库

```shell
mvn install:install-file -Dfile=IKAnalyzer6.5.0.jar -DgroupId=org.wltea.analyzer -DartifactId=IKAnalyzer -Dversion=6.5.0 -Dpackaging=jar
```

## SpringMVC

restful最后一个参数是点无法获取

```java
    /**使用以下的 @PathVariable，当 key 值为 abc 或 123 时都没有问题。*/
    @RequestMapping(value = "/release/{key}", method = RequestMethod.GET)
    @ResponseBody
    public String release(@PathVariable String key) {
        log.debug("取得key值 {}", key);
        return release;
    }

    /**但是当 key 值有「.」时就会出错，比如说「/release/a.b.c」，到了 @PathVariable 就只剩下「a.b」，「.c」不见了，原因出现 Spring MVC 预设会切掉最后一个点以后的字符串，应该是在处理「*.do」这样的 Url pattern 的关系。
    解决方式：在 @PathVariable 里使用 Regular Expression 来配置 key 值的长相。
    */
    @RequestMapping(value = "/release/{key:[a-zA-Z0-9\\.]+}", method = RequestMethod.GET)
    @ResponseBody
    public String release(@PathVariable String key) {
        log.debug("取得key值 {}", key);
        return release;
    }
```

字节流上传

参考

[How to Implement HTTP byte-range requests in Spring MVC](https://stackoverflow.com/questions/28427339/how-to-implement-http-byte-range-requests-in-spring-mvc)  
[davinkevin/MultipartFileSender gist](https://gist.github.com/davinkevin/b97e39d7ce89198774b4)  
[Implementing HTTP byte-range requests in Spring MVC](http://datum-bits.blogspot.com/2013/01/implementing-http-byte-range-requests_30.html)  
[Spring MVC大文件的断点续传（File Transfer Resume）](http://rensanning.iteye.com/blog/2248760)  
[How do I return a video with Spring MVC so that it can be navigated using the html5 \<video\> tag?](https://stackoverflow.com/questions/20634603/how-do-i-return-a-video-with-spring-mvc-so-that-it-can-be-navigated-using-the-ht)  
[FileServlet supporting resume and caching and GZIP](http://balusc.omnifaces.org/2009/02/fileservlet-supporting-resume-and.html)  

videojs

[videojs 使用教程](https://www.cnblogs.com/alicePanZ/articles/5676915.html)  
[一款开源免费跨浏览器的视频播放器--videojs使用介绍](https://www.cnblogs.com/afrog/p/4115377.html)  
[免费视频播放器videojs中文教程6.0.0更新之后](http://www.cnblogs.com/afrog/p/6689179.html)  
[用video.js开发HTML5播放视频](http://tanglilidegh.github.io/geekSalon/videojs-HTML5.html)  
[videojs--跨浏览器的HTML视频播放器（可自定义样式）](https://segmentfault.com/a/1190000006151693)
[videojs github](https://github.com/videojs/video.js)  
[videojs-errors github](https://github.com/brightcove/videojs-errors)

文件上传
[SSM框架+Plupload实现断点续传（Spring+SpringMVC+MyBatis+Plupload）](https://www.cnblogs.com/yiye/p/5798521.html)

视频直播
[编译Nginx-RTMP-Module搭建VR视频直播服务器](https://www.jianshu.com/p/7ef1b06f6c1b)  
[nginx视频直播/点播服务干货分享](https://segmentfault.com/a/1190000009124451)  
[H5视频直播扫盲](https://www.nihaoshijie.com.cn/index.php/archives/615/)  
[在Windows下搭建基于nginx的视频直播和点播系统](https://my.oschina.net/gaga/blog/478480)

## window

### 环境变量命令

 Windows命令行设置永久环境变量

 ```bat
    rem 在cmd窗口中set设置的环境变量为临时变量，如：
    set PATH=%PATH%;D:\Program Files\

    rem 使用setx设置为永久环境变量,适用于bat中：（当前用户） --有问题%path%会是当前用户和系统汇总之后的
    setx PATH "%PATH%;D:\Program Files\"

    rem 使用setx设置为永久环境变量,适用于bat中：（系统）
    setx PATH "%PATH%;D:\Program Files\" \M

```

### cmd中复制粘贴

> `alt + Space, e, k` <-- for copy  
> `alt + Space, e, p` <-- for paste.

### Win7不按Shift，直接右键显示“在此处打开命令窗口(W)”

普通文件夹右键
> 将注册表HKEY_CLASSES_ROOT\Directory\Background\shell\cmd下的键Extended改名或者删除

磁盘分区右键
> 将注册表HKEY_CLASSES_ROOT\Drive\shell\cmd下的键Extended改名或者删除

everything
> 搜索快捷方式 et -s keyword

### win10多桌面快捷键

`ctrl+win+d` 新建桌面
`ctrl+win+←/→` 切换桌面

### windows 查找服务名

```cmd

sc queryex type = service state = all | findstr /i "mysql"

```

### windows win+r常用命令

```bat

:: 打开服务
services.msc

:: 控制面板
control
control panel

:: 网络连接
ncpa.cpl

:：注册表
regedit

:: 计算器
calc
:: 记事本
notepad
:: 画图板
mspaint

:: 资源管理器
explorer

:: 控制台
mmc

devmgmt.msc：打开设备管理器控制单元命令。
wf.msc：打开高级安全Windows防火墙。
diskmgmt.msc：打开磁盘管理器。
compmgmt.msc：打开计算机管理。
lussrmgr.msc：打开用户管理程序。
fsmgmt.msc：打开共享文件夹管理程序。
taskschd.msc：打开任务计划程序。
services.msc：打开服务管理程序。
perfmon.msc：打开性能监视器程序。
gpedit.msc：本地组策略编辑器程序。

微软控制管理台程序命令的后缀都是.msc。

```

### windows清除网上邻居帐号

输入命令`control keymgr.dll`, 在弹出的窗口中删除帐号.  
samba切换帐号, `net use`查看列表, `net use \\hostname\IPC$ /DELETE`删除信息, 如`net use \\192.168.0.1\IPC$ /DELETE`  

### windows kill 进程命令

taskkill /F /IM explorer.exe